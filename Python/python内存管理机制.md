---
title: python内存管理机制
date: 2020-03-21 20:58:00
categories: Python
---
<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [内存管理和垃圾回收机制](#内存管理和垃圾回收机制)
  - [内存管理](#内存管理)
  - [垃圾回收机制](#垃圾回收机制)
    - [引用计数](#引用计数)
    - [标记清除](#标记清除)
    - [分代回收](#分代回收)
- [参考文档](#参考文档)
<!-- TOC END -->

# 内存管理和垃圾回收机制

## 内存管理
1.  Python 中一切皆对象，对象又可以分为可变对象和不可变对象。二者可以通过原地修改，如果修改后地址不变，则是可变对象，否则为不可变对象，地址信息可以通过id()进行查看

    ![python可变对象与不可变对象](http://study.jeffqi.cn/python/python_changeable_and_unchangeable_object.jpg)

2.  python有内存池机制，pymalloc机制来对内存进行申请和释放内存；当创建小的对象是，如果频繁使用c中的new/malloc会导致大量内存碎片，导致效率下降；所有python中使用内存池机制来解决这个问题；内存池先申请一块内存空间，然后分割成等大小的块数；有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。**Pymalloc会在内存池中申请空间，一般是少于256kb，如果是大的对象，则直接调用 new/malloc 来申请新的内存空间**

## 垃圾回收机制
- Python 采用 GC 作为自动内存管理机制，GC要做的有2件事，**一是找到内存中无用的垃圾对象资源，二是清除找到的这些垃圾对象，释放内存给其他对象使用**
- 引用计数
- 标记清除
- 分代回收
- 引用计数为主，其余两种为辅助回收机制

### 引用计数
1.  查看源码，每一个对象，在源码里就是一个结构体表示，都会有一个计数字段.
    ```c
    typedef struct_object {
      int ob_refcnt;    //计数
      struct_typeobject \*ob_type;
    } PyObject;
    ```

2.  PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少。一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。

- 优点
    1.  简单
    2.  实时性强，能够实时的无用的对象的内存进行释放
- 缺点
    1.  需要维护一个计数，占用额外的空间
    2.  循环引用：两个对象相互引用，且没有任何外部引用

### 标记清除
1.  为了解决循环引用带来的可能导致内存泄露的问题
2.  **第一阶段是标记阶段**，GC会把所有的 活动对象 打上标记
3.  **第二阶段是清除阶段**，把那些没有标记的对象 非活动对象 进行回收
4.  对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。
![标记清除](http://study.jeffqi.cn/python/mark-gc.jpg)
5.  如上图中，1、2、3是可到达的，而4、5就是不可到达的需要被清理掉
6.  标记清除主要是用来处理python中的容器对象如list、dict等；Python使用一个双向链表将这些容器对象组织起来
7.  清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象

### 分代回收
1.  在python中没创建一个对象，就将对象放到一个链表中，如果有引用计数就加一；从而构成一个双向链表；这个链表就是零代链表；
![分代回收1](http://study.jeffqi.cn/python/gc-generator-1.png)
![分代回收2](http://study.jeffqi.cn/python/gc-generator-2.png)
2.  检测循环引用：python会遍历零代链表，给每个计数减一，将计数为零的对象的内存释放掉；活着的对象进入下一代链表（一代链表）
![分代回收3](http://study.jeffqi.cn/python/gc-generator-3.png)
![分代回收4](http://study.jeffqi.cn/python/gc-generator-4.png)
3.  弱代假说：在零代链表中的对象python默认会认为他们会很快更新，比如创建了一个临时对象；而经过一次筛选后的对象，python会认为他们会被经常使用到；同理在二代链表中也是如此；由于循环引用，导致分配计数和释放计数的比值越来越大，当到达一个阈值后，会触发收集器执行清理操作，对所有对象引用计数减一然后回收为零的对象，添加非零对象到下一代链表中；在下一代链表中也存在这一个阈值，不过python会认为下一代的使用时间更久，所以这个阈值会更大。

# 参考文档
- https://www.jianshu.com/p/fb1d4dc8e367
- https://www.jianshu.com/p/1e375fb40506
- http://patshaughnessy.net/2013/10/30/generational-gc-in-python-and-ruby
