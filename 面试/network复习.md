<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [Day 1](#day-1)
  - [OSI七层模型](#osi七层模型)
  - [TCP](#tcp)
  - [ARP](#arp)
  - [DNS](#dns)
  - [常见协议端口号（默认UDP/TCP两种协议）](#常见协议端口号默认udptcp两种协议)
  - [DHCP](#dhcp)
  - [NAT](#nat)
  - [IP编址](#ip编址)
- [Day 2](#day-2)
  - [路由原理](#路由原理)
  - [静态路由](#静态路由)
  - [RIP（520/UDP、路由矢量、内部网关协议、报文 30s 、广播更新、180s 未更新记为不可达）](#rip520udp路由矢量内部网关协议报文-30s-广播更新180s-未更新记为不可达)
  - [OSPF（链路状态路由协议、内部网关协议、89、IP、组播更新224.0.0.5、224.0.0.6）](#ospf链路状态路由协议内部网关协议89ip组播更新224005224006)
- [Day 3](#day-3)
  - [ACL](#acl)
  - [BGP](#bgp)
  - [路由策略](#路由策略)
- [Day 4](#day-4)
  - [IPv6](#ipv6)
    - [IPv6v4过渡机制](#ipv6v4过渡机制)
    - [ICMPv6的各种名词](#icmpv6的各种名词)
    - [扩展](#扩展)
  - [STP](#stp)
  - [VLAN](#vlan)
- [Day 5](#day-5)
  - [VRRP（虚拟路由冗余协议）](#vrrp虚拟路由冗余协议)
  - [MPLS](#mpls)
    - [MPLS](#mpls-1)
    - [MPLS VPN](#mpls-vpn)
  - [IPsec VPN](#ipsec-vpn)
    - [IKE协议](#ike协议)
- [Day 6](#day-6)
  - [python](#python)
- [Day 7 算法实战](#day-7-算法实战)
  - [算法实战(看懂算法原理)](#算法实战看懂算法原理)
  - [二分查找](#二分查找)
  - [冒泡排序](#冒泡排序)
  - [插入排序](#插入排序)
  - [快速排序](#快速排序)
  - [选择排序](#选择排序)
  - [树](#树)
    - [二叉树](#二叉树)
    - [二叉查找树](#二叉查找树)
    - [平衡二叉查找树（红黑树）](#平衡二叉查找树红黑树)
    - [B-tree（B树）](#b-treeb树)
    - [B+树](#b树)
    - [B树与B+树异同](#b树与b树异同)
    - [递归树](#递归树)
<!-- TOC END -->

#  Day 1

## OSI七层模型
1.  应用层
2.  表示层
3.  会话层
4.  传输层
5.  网络层
6.  数据链路层
7.  物理层

## TCP
1. 三次握手、四次挥手
2. 滑动窗口
3. 有限状态机
4. 序列号确认号
    - 发送端： seq = 前一次收到的ack；ack = 自己的 ack
    - 接收端： seq = 自己的sqe；ack = 收到的数据大小 + 收到的 seq
    - 序列号和确认号可以保证传输的可靠性，发送方发送数据时可以按照顺序发送数据包；接收方可以按照序列号将数据包顺序组装；序列号可以告诉接收方发送的是哪一个数据包，确认号可以告诉发送方，我已经确认接收了那些数据包，下一次需要从哪个数据包开始发送。

## ARP
1.  ARP:地址解析协议，将IP地址转换成对应的mac地址，完成IP地址到Mac地址的映射；
    - 工作流程：a向b发送数据，首先查询本地的ip地址到mac地址的缓存，如果有直接发送；如果没有，发起广播发起广播查询，带上自己的ip、mac地址和目的ip地址；其他主机收到信息查看ip地址是否是自己的，不是则丢弃；如果是则将a的ip和mac地址映射存入arp缓存，并将自己的mac地址信息发送会给主机a；主机收到信息后，将b的ip与mac地址信息存入缓存；发送信息；
1. 反向ARP
    - 根据源设备 MAC 地址通过广播获取 IP地址的过程的地址解析协议；
2. 代理ARP
    - 代理arp 即arp 欺骗，路由器通过发送代理arp 信息，让主机认为路由器即为目的主机。通过这种方式，路由器可以转发数据流。
3. ARP欺骗的原理
    - ARP欺骗利用的是ARP缓存机制的一个缺陷。当主机收到一个ARP响应包时，主机不会去确认是否有想这个IP地址发送过ARP请求；会直接将对应的IP和mac地址存入到arp缓存中，如果原来存在这个IP则会替换原来的映射关系；

## DNS
1.  DNS：能够将域名与 IP 地址进行相互转换
2.  查询方式
    1.  迭代查询：主机箱本地 DNS 服务器发起域名解析，如果本地 DNS 服务器不知道，则向根 DNS 服务器发起查询，根域名服务器如果不知道，则将自己知道的顶级 DNS 服务器的地址发送给本地服务器，让他去其他顶级服务器查询；
    2.  递归查询：主机向本地 DNS 服务器请求域名解析，如果本地 DNS 服务器不知道，则本地 DNS 服务器将以 DNS 客户的身份将该条解析传递给下一个根域名服务器（常用）；
3. 端口号，TCP/UDP
    - 53端口
4. 什么状况下用TCP
    - DNS 服务器分为，主 DNS 服务器和辅助 DNS 服务器；主 DNS 服务器读取自己本地的关于本区域的 DNS 信息，辅助 DNS 服务器从该区域的主 DNS 服务器获取 DNS 信息；**DNS服务器之间传输时使用TCP，而客户端与DNS服务器之间传输时用的是UDP**；

## 常见协议端口号（默认UDP/TCP两种协议）
1. FTP：20（发送指令）、21（文件传输）
2. DNS：53
3. DHCP：67/UDP（目的端口/接收）、68/UDP（源端口/发送）
4. HTTP：80/TCP    HTTPS：443
5. Telnet：23/TCP
6. ssh：22/TCP

## DHCP

1. 过程
    1.  发现阶段：客户端广播发送 DHCP discover 消息请求；
    2.  提供阶段：DHCP 服务器收到 DHCP discover 后，从地址池中选出一个 IP 地址，以广播的形式发送 DHCP offer 消息给客户端；
    3.  选择阶段：客户端收到 DHCP offer 后以广播的形式发送一个 DHCP request 消息。这个消息是想向 DHCP 服务器申请 DHCP offer 中的 IP 地址；有可能会收到多个 DHCP 服务器的offer，一般客户端会选择第一个到达的，其他的 DHCP 服务器收到这个 request 信息后，知道客户端拒绝了自己的 offer，所以开始回收自己的 offer；
    4.  确认阶段：DHCP 服务器收到客户端发送的 request 信息，以单播的形式回复 DHCP ack 信息给客户端确认分配这个 IP 地址，并从自己的地址池中删除这个 IP 地址；
2. 续租时间
    1.  客户端获取 IP 地址成功后，会在 1/2 租约时间的时候发送 request 信息，向 DHCP 服务器请求续约
    2.  服务器收到客户端发送的 DHCP request 信息会回复一个 DHCP ack 信息，客户端收到后就表示续约成功，从当前时间算起或得一个新的租约期限；如果客户端没有收到 DHCP ack 信息，或者服务端没有收到客户端的 DHCP request 报文，客户端会在到达租约 7/8 的时候再次发送 DHCP request 报文，请求续组，如果成功则在当前时间基础上获得一个新的租约周期
    3.  如果第二次也没有成功只有等到租约结束后，重新申请新的 IP 地址
    4.  如果在 1/2 租约是发起续组请求，DHCP 服务端已经不存在这个 IP，则 DHCP 服务器会单播发送 DHCP nack 信息，客户端收到后会发送 DHCP discover 信息，如果没有回复，在 7/8 租约时再次发送 DHCP discover 包，如果没有成功，只有在过期后重新获取 IP

## NAT
1.  NAT 技术能够将数据包中的 IP 地址进行替换，使是有网络能够访问公网；同时极大的缓解了 IPv4 地址紧缺的问题；保护内网安全
2.  NAT 优缺点

优点 | 缺点
---|---
节省 IP 地址 | 增加转发延迟
解决 IP 地址重叠 | 丧失端到端之间的通信能力
增加接入 Internet 的弹性 | 部分应用不支持 NAT
网络变更减少重编址 | 需要部分内存空间来存储 NAT 转换表
对外影藏自己的内部地址，安全 | 需要 CPU 进行 NAT 操作、需要内存资源存储 NAT 信息

2. SNAT：静态 NAT
    1.  内部地址与全局地址一一对应；缺点是一个内网 IP 独占一个公网 IP；即使没有使用的时候，也不能给其他人使用；可扩展性不高；
    2.  支持 IP 到 IP 的映射；端口到端口的映射

3.  s-nat \ d-nat：数据报的源地址和目的地址的转化，并保存修改前后映射关系
    1. S-NAT
        1.  流量出去时改源地址（snat）；回来时改目的地址（un_snat）
    2. D-NAT
        1.  流量进来时改目的地址（dnat）；出去时改源地址（un_nat）
4. PAT：端口地址转换
    1.  对数据包的源地址和端口均进行转换，通过这种转换，可以使多个内部本地地址同时共享同一个公网地址，通过 IP + 端口的方式来识别不通的源，也就是多对一的映射。
5. 解决地址冲突问题
    1.  当 NAT 地址池中的地址用完后，其他未获得 IP 地址的主机无法 NAT 只能等待有 IP 地址空闲后才能进行 NAT
    2.  使用 PNAT

## IP编址
1.  1.0.0.0~126.255.255.255 私有地址：10.0.0.0~10.255.255.255
2.  127.0.0.0~191.255.255.255 私有地址：172.16.0.0~172.31.255.255
3.  192.0.0.0~224.255.255.255 私有地址：192.168.0.0~192.168.255.255
1. 子网掩码
      - 用于标识一个 IP 那些是主机所在网段，那些标识位是主机的位掩码
      - IP 地址由子网掩码分为两部分：网络号和主机号；网络号用来确定所属网段；主机号用来唯一标识主机；
      - 主机位全为 0 的地址，称为网络地址，表示一个网段；
      - 主机位全为 1 的地址，称为广播地址；
      - 作用：
          1.  将一个大的 IP 网段，划分成小的 IP 网段，节约地址；减少 IP 地址的浪费；
          2.  屏蔽 IP 的一部分以区别网络标识，和主机标识；说明该主机实在局域网上，还是在远程网；
2. VLSM/CIDR
    1.  VLSM：可变长子网掩码
        1.  在一个主类(A、B、C类)网络内包含多个子网掩码的能力，以及对一个子网的再进行子网划分的能力
        2.  作用：节约 IP 地址空间；减小路由表的大小；
    2.  CIDR：无类别域间路由
        1.  取消IP地址的分类结构，将多个地址块聚合在一起生成一个更大的网络，以包含更多的主机

# Day 2

## 路由原理
1.  接入到几个不同的网络之中，通过检查数据包的 IP 地址信息然后通过与路由表里面的信息进行对比，决定发送到的下一跳该往哪里走；可以实现不同网段的通信；
2.  路由表：路由表是路由器工作的基础，存储着路由信息，记录网络中的地址记录，记录着网络的拓扑信息，决定着数据的转发路径；
3.  路由汇总：将多个明细路由汇集成一个路由广播，减少路由器维护的路由表条数；

## 静态路由
1.  手工指定路由器转发某个网络的数据包下一次该往哪里走；一般由管理员手工添加，比较稳定，不会发生改变；
2.  缺省路由：设置一条缺省路由，在路由器对比过路由表之后没有找到相应的路由条目时，会将数据包发送给默认的转发接口
3.  下一跳出口导致ARP问题：如果静态路由指定的下一跳借口，则会认为对面的接口和自己是同一网段的。于是会发起 ARP 请求，如果对方开启了 ARP 代理，则会回复 ARP 请求的目的 MAC 就是自己的直连的端口；如果没有那么就无法通信；如果这个路由器要访问的是对端路由器后面的主机，访问一台主机就会缓存一个 PC 和他的 MAC 地址对应信息，如果主机量过于庞大，这会耗尽这个路由器的内存；为了解决我们可以采用下一跳地址的方式指定静态路由，每次只需要维护一个 ARP 缓存记录；
4.  管理距离：不同的协议有自己不同的计算度量值得方法，如 RIP 通过条数来决定路径的传输距离，EIGRP 通过计算网络中的带宽和延迟来计算传输距离；没有可比性，通过统一单位，来衡量不同协议的路径开销，从而来选择最优路径；

## RIP（520/UDP、路由矢量、内部网关协议、报文 30s 、广播更新、180s 未更新记为不可达）
1.  距离矢量路由协议，通过衡量条数来衡量网络距离
2.  直连设备距离为 0，中间经过了多少个路由器距离就加几，最大 15 跳，16 跳时不可达；
3.  特点：有类别路由协议；广播更新；基于UDP，端口号520
3.  RIP1 与 RIP2
    1.  RIPv1是有类路由协议，RIPv2是无类路由协议
    2.  RIPv1不能支持VLSM，RIPv2可以支持VLSM
    3.  RIPv1没有认证的功能，RIPv2可以支持认证，并且有明文和MD5两种认证
    4.  RIPv1没有手工汇总的功能，RIPv2可以在关闭自动汇总的前提下，进行手工汇总
    5.  RIPv1是广播更新，RIPv2是组播更新，
    6.  RIPv1对路由没有标记的功能，RIPv2可以对路由打标记（tag），用于过滤和做策略
    7.  RIPv1发送的updata最多可以携带25条路由条目，RIPv2在有认证的情况下最多只能携带24条路由
    8.  RIPv1发送的updata包里面没有next-hop属性，RIPv2有next-hop属性，可以用与路由更新的重定
4.  防环机制
    1.  水平分割：从邻居学到的路由表，不会再发给邻居；减少网络消耗，防止路由环路
    2.  毒性翻转：从邻居学到的路由表，发回给邻居，没发送一次跳数加 1，到达 16 跳后认为不可达
    3.  记最大跳数：定义最大跳数 16 跳不可达
    4.  路由毒化：当拓扑发生改变时，将失效路由标记为不可达
    5.  触发更新：一旦检测到路由崩溃，立即广播路由刷新报文，而不等到下一刷新周期
    6.  抑制计时器：防止路由表频繁翻动，增加网络稳定性 ，阻止定期更新的消息在不恰当的时间内重置一个已经坏掉的路由

## OSPF（链路状态路由协议、内部网关协议、89、IP、组播更新224.0.0.5、224.0.0.6）
1.  COST＝参考带宽（10的8次方）/ 接口带宽
1.  OSPF 三张表：
    1.  邻居表
    2.  LSDB
    3.  路由表
1. 距离矢量与链路状态
    1.   每个节点接收来自与其直接邻接节点的路由信息，并执行路由计算，将计算结果回传给直接邻接的节点，收敛慢；链路状态是记录的整个网络的拓扑结构，节点向相邻网络广播自己和邻居的信息，每当收到自己的信息后就计算网络拓扑，找出最优路径，收敛快，无环路；
2. OSPF原理
    1.  开机后会向周围链接的路由器发送 hello 包建立邻居关系，建立后发送 LSA,告诉自己的邻居自己的邻居路由器和自己的链路状态信息，这个过程中，路由器会不断的发送 LSA，记录 LSA，转发 LSA,最后形成链路状态数据库，形成拓扑接图，通过 SPF 算法计算 LSDB 得出最优路径形成路由表
3. OSPF的邻居建立过程7个步骤
    1.  down、init、towway（选举DR、BDR）、ex-start（决定主从）、exchange、loading、full
4. OSPF的LSA种类1,2,3,4,5,7需要看
    1.  （1）路由器LSA Router LSA：区域中路由产生，允许在本区域内洪泛，不允许跨越ABR
    2.  （2）网络LSA Network LSA：DR生成，描述其在该网络上连接的所有路由器以及网段掩码信息；只在本区域Area内洪泛，不允许跨越ABR
    3.  （3）网络汇总LSA Network Summary LSA：ABR产生的连接区域的汇总信息；通知本区域通往域外的信息
    4.  （4）ASBR Summary LSA：ABR 产生，主机 LSA，指向 ASBR 路由器
    5.  （5）自治系统外LSA AS External LSA：ASBR 产生，告诉本自治区的路由器通往外部自治区的路径；外部路由通过重发布，引入OSPF路由域，由 ASBR 生成五类的 LSA 发送进 OSPF 区域；不允许进入 stub 存根区 & NSSA区
        1.  OE2 开销= 外部开销；
        2.  OE1 开销= 外部开销+ 内部开销；
    7.  （7）NSSA中的外部LSA NSSA External LSA：在 NSSA 区域中 ASBR 针对外部网络产生类似于 LSA5 的 LSA 类型7；LSA类型7只能在NSSA区域中洪泛，到达NSSA区域ABR后，NSSA ABR将其转换成LSA类型5外部路由，传播到 Area 0，从而传播到整个OSPF路由域
5.  特殊区域拒绝的 LSA：
    1.  stub：LSA4、LSA5
    2.  totally stub：LSA3、LSA4、LSA5（默认类似 LSA3 的默认路由）
    3.  not-so-stub：LSA4、LSA5、LSA7（允许，进过 ABR 7类 转 5类）
    4.  totally-not-so-stub：只有 LSA2、LSA1、ABR下发一条类似 LSA3 的默认路由
6.  虚链路：
    1.  在某个非骨干区域上发生了区域分裂，导致某个非骨干区域无法和骨干区域相连，就需要虚链路；通过建立虚拟通道可以建立Area 0的邻居关系
5. OSPF的路由认证HMAC的过程
    1.  MD5 HMAC 的使用表明使用一个共享的密钥用于产生hash值.路由器发送一个消息产生MD5 hash值,并将它置于要发送的通告中,在接收时,接受方使用相同的密钥和MD5值,重新计算分组内容和分组头的hash值,如果结果相同,这个消息就是真正来自于一个可信赖的主机,如果不相同,它必须丢弃
6. OSPF区域划分问题

# Day 3

## ACL
1.  标准 acl 和扩展 acl
    1.  ACL默认在最后拒绝所有
    2.  标准访问列表只拒绝或允许原IP地址
    3.  扩展ACL的筛选更加精确广泛
    4.  ACL列表写好后，需要运用到接口上，标准ACL离目的IP更近，扩展ACL应用在离源IP更近的接口
    5.  ACL不会过滤自身路由器的信息
1. 过滤特定协议
    1. ICMP：protocol ICMP
    2. HTTP：protocol tcp port 80 /eq www
    3. OSPF：protocol ip port 89 /
    4. DHCP：protocol udp eq bootps

## BGP
1.  为什么要使用 BGP：
    1.  大量路由需要承载，BGP能够容纳上万条
    2.  策略能力强大，可以很好的实现路由策略与数据控制
2.  条件：自治区AS号、建立TCP链接、指定可达
3.  
1. 179/TCP
2. 选路原则能报出多少种
    1.  优选具有最大Weight值的路由（weight 不传递）
    2.  优选具有最大Local_Pref值的路由（IBGP 传递）
    3.  优选起源于本地的路由
    4.  as-path最短
    5.  ORIGIN
    6.  优选MED最小的路由
    7.  优选EBGP邻居的路由（相对于IBGP）
    8.  优选到NEXT_HOP最近的路由
    9.  BGP负载均衡
    10. 优选最老的EBGP邻居的路由
    11. 优选ROUTE-ID最小的
    12. 优选Cluster_List最短的路由
    13. 优选邻居IP地址最小的
4.  属性
    1.  公认属性
        1.  比遵：BGP必须识别，信息必须要包含
        2.  自觉：BGP能识别，可不包含
    2.  可选属性
        1.  可传递：可以不支持，但是传递时都需要传递
        2.  不可传递：可以不支持，可以在传递时忽略不传递
3. community属性：可选传递属性，不支持该属性的BGP router原封不动的将community值传递给下游BGP邻居
    1.  no-advertise：不发给其他任何BGP peer
    2.  no-export：不传递给任何EBGP peer（联邦EBGP会传递）
    3.  local-as：只在本AS内传递（如果定义了联邦会在联邦成员中传递）
    4.  atomic_aggregate及aggregator：汇总路由丢失明细路由的路径属性，需要给下游邻居警告，提示汇总地及汇总地AS

## 路由策略
1. ACL
    1.  标准 ACL
        1.  只能匹配路由前缀，不能匹配路由前缀长度
    2.  扩展 ACL
        1.  源部分、目的部分、前缀或掩码
2. 各种路由过滤工具
    1.  route-map：
        1.  作用
            1.  重分发是进行进行路由过滤
            2.  策略路由
            3.  NAT 转换
        2.  规则
            1.  从上到下依次匹配 match 语句，如果中了就执行 set 动作；否则进入下一跳
        3.  特点
            1.  使用match命令匹配特定的分组或路由, set修改该分组或路由相关属性。
            2.  Route-map中的每个序列号语句相当于于访问控制列表中的各行。
            3.  Route-map默认为permit ,默认序列号为10 ,序列号不会自动递增,需要指定序列号
            4.  末尾隐含deny any
            5.  单条match语句包括多个条件时,使用逻辑or运算; 多条match语句时,使用逻辑and运算。
    2.  distribute-list：分发列表
        1.  用于控制路由更新的一个工具
        2.  只能过滤路由信息,无法过滤LSA
    3.  prefix-list：前缀列表
        1.  前缀列表的可控性比访问列表高得多,支持增量修改,更为灵活
        2.  可匹配路由前缀中的网络号及前缀长度,增强了匹配的精确度
        3.  前缀列表包含序列号,从最小的开始匹配
        4.  如果前缀不与前缀列表中的任何条目匹配,将被拒绝

# Day 4

## IPv6

### IPv6v4过渡机制
1.  双栈策略：
    1.  相近网络层协议，运行于相同的物理硬件之上，其上都是基于 TCP 和 UDP，那么如果主机同时支持这两种机制就能正常使用；
2.  隧道技术：
    1.  利用隧道技术可以通过现有的运行 IPv4 协议的 Internet 骨干网络(即隧道)将局部的 IPv6 网络连接起来；路由器将IPv6的数据分组封装入IPv4；隧道技术只要求在隧道的入口和出口处进行修改，对其他部分没有要求，因而非常容易实现。但是隧道技术不能实现IPv4主机与IPv6主机的直接通信
3.  网络地址转换/协议转换技术：
    1.  在IPv6节点与IPv4节点的通信时需借助于中间的协议转换服务器，此协议转换服务器的主要功能是把网络层协议头进行IPv6/IPv4间的转换，以适应对端的协议类型；但是不是所有的应用都支持，比如有的数据包中内嵌自己的协议信息就无法转换如 DNS 等；

### ICMPv6的各种名词
1.  类型
    1.  差错消息
        1.  1类：目的不可达
        2.  2类：数据包过长
        3.  3类：超时
        4.  4类：参数错误
    2.  信息消息
        1.  128类：
        2.  129类：
2.  PMTUD（路径上的最小接口MTU）
    1.  发送至后被回复 MTU 过大，设置为回复值
3.  NDP（邻居发现机制）
    1.  替代了 IPv4 的 ARP 和 ICMP 路由器发现，它定义了使用 ICMPv6 报文实现地址解析，跟踪邻居状态，重复地址检测，路由器发现以及重定向等功能
    2.  为避免泛滥：3个RS
4.  ICMPv6 DAD（重复地址检测）
    1.  在接口使用某个IPv6单播地址之前进行的，主要是为了探测是否有其它的节点使用了该地址
5.  ICMPv6重定向
    1.  通知链路上的节点，在链路上存在一个更好的前转数据包的路由器。接收到这个ICMPv6重定向消息的节点可以根据重定向消息中新的路由器地址修改它的本地路由选择表

### 扩展
1.  包头和扩展包头
    1.  扩展报头只有目标节点查看，其他节点不查看和处理大部分扩展报头
    2.  要按顺序查看扩展报头的内容
2.  128bit 位，冒分十六进制；地址简写，前导有多个连续的 0 可以简写为一个；一个或连续多个字段都为 0 可以直接省去，只剩下 xxxx::xxxx；
3.  特点：
    1.  多等级层次有助于路由聚合，提高了因特网网络路由的效率及可扩展性
    2.  包头更加简洁，字节更少效率更高；同时提供更多灵活性
2.  无广播（组播、单播、任意播），无 ARP
    1.  单播地址（Unicast Address）：标识一个接口，目的地址为单播地址的报文会被送到被标识的接口
    2.  组播地址（Multicast Address）：标识多个接口，目的地址为组播地址的报文会被送到被标识的所有接口
    3.  任播地址（Anycast Address）：标识多个接口，目的为任播地址的报文会被送到最近的一个被标识接口，最近节点是由路由协议来定义的
    4.  IPv6没有定义广播地址

## STP
1. STP 操作
    1.  每个广播域选择一个根桥
    2.  每个非根桥上选择一个根端口
    3.  每个段选择一个指定端口
    4.  选择一个非指定端口
1. 交换机接口状态
    1.  disbale：无法送任何报文
    2.  blocking：不发送也不转发帧，接收但是不发送 BPDU，不学习 MAC 地址
    3.  listening：不发送也不转发帧，接收并转发 BPDU，不学习 MAC 地址
    4.  learning：不接受也不转发帧，接收并转发 BPDU，学习 MAC 地址
    5.  forwarding：接收并转发帧，接收并转发 BPDU，学习 MAC 地址
1.  STP拓扑变更
    1.  a挂掉后，b能感知到，于是b从根端口向葛巧方向发送 TCN BPDU 收到 TCN ACK 之前一直发送
    2.  c收到 TCN BPDU 后回复 TCN ACK 同时向自己的根端口转发这个 TCN BPDU
    3.  root 收到后会送一个 TCN ACK 给 c
    4.  root 修改自己的配置 BPDU，来告知整个网络关于拓扑的变更情况；设置一段时间的拓扑变更 TC 标志置位，时间为 maxage 加 转发延时默认 35s
    5.  交换机收到 root 发送的 tc 标志的 BPDU，使用转发言辞计时器默认 15s，来更新 MAC 地址中的条目。是 mac 地址条目快速更新，持续这个过程指导不再接受来之root的 TC BPDU
2. 数据链路层帧格式
3. MSTP拓扑变化机制
    1.  形成多棵无环路的树，解决广播风暴并实现冗余备份。
    2.  多棵生成树在VLAN间实现负载均衡，不同VLAN的流量按照不同的路径转发。

4. RSTP拓扑变化机制
    1.  端口角色：根端口、指定端口、替代端口、备份端口
    2.  端口状态：转发、丢弃、学习
    4.  变更机制
        1.  RSTP中，只有当非边缘端口过渡到forwarding状态才会触发拓扑变更
        2.  当交换机检测到一次拓扑变更时；
            1.  为根端口及所有的非边缘指定端口启动一个TC while timer，timer的值等于2倍的hello-time计时器
            2.  向上述端口洪范 MAC 表
            3.  注意只要 TC while timer 在端口上计时，端口发送出去的BPDU就会进行TC bit置位，该BPDU也会从根端口往外发送
        3.  交换机收到 TC bit 置位的 BPDU时
            1.  清除从所有接口学习到的MAC表项，除了收到TC BPDU的那个接口
            2.  激活TC while timer，然后从所有的非边缘指定端口及根端口往外发送TC置位的BPDU
5. BPDU的数据包结构
    1.  协议ID
    2.  协议版本标识：stp 0、rstp 2、mstp 3
    3.  BPDU 类型：MSTP 0x02 ; 0x00:STP的配置 BPDU; 0x80:STP的TCN BPDU ; 0x20:RSTP BPDU或MST MBPDU
    4.  标识位：左高右低 7~0
        1.  0、7：tc和tca
        2.  2：转发
        3.  3：学习
        4.  4、5
            1.  00：位置
            2.  01：替代、备份
            3.  10：根端口
            4.  11：指定端口
    5.  根桥BID：网桥优先级 + MAC 地址
    6.  根路径开销：本端口累计到根桥的开销
    7.  发送者BID：本交换机BID
    8.  发送者PID：本端口PID
    9.  message：BPDU消息年纪
    10. max age：信息老化时间
    11. hellotime：连个相邻BPDU豹纹的时间间隔
    12. forward delay：转发延时
6. 二层网络环路问题会导致广播风暴，导致网络瘫痪；使用生成树协议将某些端口 block 掉从而实现物理上的冗余，防止环路产生；当拓扑发生变更的时候，生成树协议能够探测到这些变化，并且及时自动的调整接口状态，从而适应网络拓扑的变化，实现链路冗余

## VLAN
1. 广播域与冲突域
    1.  广播域：广播域就是说如果站点发出一个广播信号后能接收到这个信号的范围。通常来说一个局域网就是一个广播域
    2.  冲突域指在网络内部数据分组所产生与发生冲突的这样一个区域称为冲突域，所有的共享介质环境都是一个冲突域
2. VLAN号的范围：0~4095
    1.  0，4095：保留
    2.  1：默认
    3.  2~1001：以太网vlan
    4.  1002~1005
    5.  1006~4096：在特殊平台保留
3. 本帧VLAN：支持VLAN与不支持VLAN的设备相互兼容
    1.  Native VLAN所属的帧在经过trunk时不打标签
    2.  Native VLAN在Trunk两端必须匹配，否则会出现VLAN流量互串
    3.  默认的native vlan是vlan 1；建议一个生僻的vlan
4. GVRP/VTP
    1.  VTP：简化大型园区网中VLAN信息库同步的问题；通过转发vlan信息来简化配置操作
        1.  server：可以增删改vlan，发送转发，同步
        2.  client：只能转发，收取，同步
        3.  transport：增删改，可转发接收，不同步
    2.  GVRP：GVRP 交换机之间能够相互交换 VLAN 配置信息，裁剪不必要的广播和未知单播流量以及通过在干线上的交换机动态创建和管理 VLAN
5. VLAN间的通信
    1.  路由器路由
    2.  三层交换机

# Day 5

## VRRP（虚拟路由冗余协议）
1.  VRRP可以通过把多台设备（路由器、交换机、防火墙等）虚拟化成一台设备，然后通过配置虚拟IP地址作为网关就能实现对网关的备份（这虚拟IP地址是代表整个VRRP组内的所有设备），当其中一台设备出现故障之后，VRRP组内其他设备会通过某些机制来接替故障设备的工作
    1.  虚拟设备、主设备、备用设备、VRID、虚拟IP、虚拟MAC、IP拥有者、优先级（1~254;0为不产参加选举，255直接成为master）、可抢占
2.  状态：
    1.  初始状态（Initialize）：刚刚配置配置或者发生故障
    2.  活动状态（Master）：
        1.  定期发送VRRP报文。
        2.  以虚拟MAC地址响应对虚拟IP地址的ARP请求。
        3.  转发目的MAC地址为虚拟MAC地址的IP报文。
        4.  如果它是这个虚拟IP地址的拥有者，则接收目的IP地址为这个虚拟IP地址的IP报文。否则，丢弃这个IP报文。
        5.  如果收到比自己优先级大的报文则转为Backup状态。
        6.  如果收到优先级和自己相同的报文，并且发送端的IP地址比自己的IP地址大，则转为Backup状态。
        7.  当接收到接口的Shutdown事件时，转为Initialize。
    3.  备份状态（Backup）
        1.  接收Master发送的VRRP报文，判断Master的状态是否正常。
        2.  对虚拟IP地址的ARP请求，不做响应。
        3.  丢弃目的MAC地址为虚拟MAC地址的IP报文。
        4.  丢弃目的IP地址为虚拟IP地址的IP报文。
        5.  Backup状态下如果收到比自己优先级小的报文时，丢弃报文，立即切换为Master（仅在抢占模式下生效）。
        6.  如果收到优先级和自己相同或者比自己高的报文，则重置定时器，不进一步比较IP地址。
        7.  当接收到接口的Shutdown事件时，转为Initialize。
        8.  如果MASTER_DOWN_INTERVAL定时器超时，则切换为Master。
    4.  选举出master，发送虚拟mac地址arp报文，发送vrrp报文，出问题，选举新master，发送新虚拟mac地址arp报文；如果原master复活，抢占式比较vrrp报文优先级，谁高谁就会是master，非抢占式，原master等待现master出问题，重新选举master；如果同时有多个成为master则比较其IP地址大小，大的选举为master
3.  两种模式
    1.  主备备份模式：只有master转发数据包，响应请求
    2.  负载分担模式：通过创建多个拥有不同虚拟IP的VRRP组，为不同的VLAN指定网关实现负载分担；每个设备有一个master区域，和几个slave区域，只转发自己的master区域的数据报文，当其他master有出问题的时候，会接手其他master区域的数据报文转发工作；

## MPLS

### MPLS
1.  多协议标签转发；新型转发机制，基于标签转发；
2.  角色
    1.  进行MPLS标签交换和报文转发的网络设备称为标签交换路由器LSR（Label Switching Router）；
    2.  由LSR构成的网络区域称为MPLS域（MPLS Domain）
    3.  位于MPLS域边缘、连接其他网络的LSR称为边缘路由器LER（Label Edge Router）
    4.  区域内部的LSR称为核心LSR（Core LSR）
3.  工作简介：IP报文进入MPLS网络时，MPLS入口的LER分析IP报文的内容并且为这些IP报文添加合适的标签，所有MPLS网络中的LSR根据标签转发数据。当该IP报文离开MPLS网络时，标签由出口LER弹出
4.  三张表
    1.  FIB：转发信息表
    2.  LIB：标签信息表，本地生成一个标签并分发给LDB邻居，也从邻居接收标签，本地标签和远程标签存储在本地LIB表中
    3.  LFIB：标签转发信息表
5.  小结
    1.  采用MPLS，可避免IP路由的逐跳转发情况，减少对数据包的深入分析，借助标签建立二层的快速转发路径，使得数据沿着一条预先建立的路径快速的转发。
    2.  数据包进入MPLS网络的入口路由器上被进行一次三层查找，而在此之后的LSR只是简单的标签交换动作，无需进一步分析三层的信息
    3.  每个LSR必须在数据转发之前建立好LIB，及FIB,当LFIB 表中进行查找，再根据LFIB表中指示的相
cef
### MPLS VPN
1. 工作原理
    1.  传统路由器专用网络：通过租用运营商之间的点对点线路进行连接：
        1.  路线专享，带宽独享，流量受保护
        2.  价格昂贵
    2.  虚拟专用网VPN：通过运营商基于共享的网络平台创建的点对点的虚链路进行连接
        1.  价格低廉
    3.  网络的边缘行为、网络的中心行为以及如何建立标记交换路径
    4.  当网络数据包进入MPLS网络时，对网络数据包进行解包，计算归属的FEC，生成标签（Label）。当网络数据包在MPLS网络中传输时，路由决策都是基于Label，路由器不再需要对网络数据包进行解包。并且Label是个整数，以整数作为key，可以达到O(1)的查找时间。大大减少了路由决策的时间
    5.  控制层面
    6.  转发层面
2. 双PE防环模型
    1.  ospf：防环健壮性
PHP倒数第二条弹出机制，机实现原理
RD、RT
## IPsec VPN
1. IPsec框架
    1.  IPSEC是一个框架，而非一个协议。框架里有很多个部分，如源认证、隐私性、完整性，每一部分都可以对应一个协议
    2.  散列函数：
        1.  固定大小，雪崩效应，单向，冲突避免
        2.  中间人攻击
2. 对称与非对称加密算法
    1.  对称加密：DES，AES
    2.  非对称加密：RSA、ECC
### IKE协议
1.  建立IPsec的双方进行认证
2.  通过秘钥交换，产生用于加密和hmac的随机秘钥
3.  协商协议参数
4.  ike sa维护了安全防护ike协议的细节，ipsec维护了安全防护实际用户流量的细节
5.  ike
    1.  isakmp:本质协议，决定了包封装与交换，还有模式切换
    2.  skeme：决定ike的秘钥交换方式
    3.  oakley：决定了ipsec的框架设计
6.  IKE的两阶段和三个模式
    1.  第一阶段-》ikesa
        1.  主模式：6个包交换
            1.  1~2包：确认合法对等体；协商ike策略（机密策略、散列函数、DH组、认证方式、秘钥有效期）；接收方选择策略
            2.  

# Day 6

## python
1. 装饰器：在代码运行期间，对函数进行功能添加
    1.  在使用装饰器后，原函数的 __name__ 参数会变成装饰器函数的名称需要使用 @functools.wrap(func) 来将名字命名；装饰器可以在不修改原函数的情况下实现功能的追加
2. 迭代器与生成器
    1.  生成器：列表元素按照某种算法推算出来，从而避免浪费较大的空间，循环计算；实现了next方法
        1.  通过调用next(generator)
        2.  通过在函数中添加yield关键字，会生成一个generator对象
        3.  延迟处理，结果在需要时才会计算产生
    2.  迭代器：对象必须提供一个next方法，执行该方法要么返回迭代中的下一项，要么就引起一个stoplteration异常，以终止迭代（只能往后走，不能往前退）这种对象成为迭代器对象；而可迭代对象指的是实现了一个iter方法，调用iter方法来获取迭代器对象，调用迭代器对象的next方法循环遍历取值；
        1.  判断：isinstance()：iterable（可迭代对象）；iterator（迭代器）
        2.  迭代器是惰性的，只有需要时才返回下一个，数据可以无限大
        3.  数据流，看做有序序列，但是不知道有多大，只能通过next获取，直到取完
3. 各种推导式
    1.  list
        ```py
        a = [x for x in range(10) if x % 2 == 0]
        a = [string.upper()]
        ```
    2.  dict
        ```py
        d = {k.lower(): dict.get(k.lower(), 0) + dict.get(k.upper(),0) for k in dict.keys() if k.lower in [a, b]}
        d = {k:v for v,k in dict.items()}
        ```
    3.  set
        ```py
        s = ｛x for x in range(10)
        ```
4. 迭代函数
    1.  递归函数：程序调用自身的编程技巧称为递归
    2.  迭代函数：迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值
5. 常用模块
    1.  如何使用模块
        1.  将路径添加到 PATH 加入环境变量：sys.path.append('..')；程序会优先在当前的执行目录下寻找，然后再去所有的环境变量中寻找
        2.  import module：同级目录引用；from ... import ...：同级文件子文件引用
    2.  常用模块
        1.  os模块：与操作系统交互的一个接口
            ```py
            os.remove() 删除文件
            os.rename() 重命名文件
            os.listdir() 列出指定目录下所有文件
            os.chdir() 改变当前工作目录
            os.getcwd() 获取当前文件路径
            os.mkdir() 新建目录
            os.rmdir() 删除空目录(删除非空目录, 使用shutil.rmtree())
            os.makedirs() 创建多级目录
            os.removedirs() 删除多级目录
            os.wait() 暂时未知
            os.path模块：
            os.path.split(filename) 将文件路径和文件名分割(会将最后一个目录作为文件名而分离)
            os.path.dirname(filename) 返回文件路径的目录部分
            os.path.basename(filename) 返回文件路径的文件名部分
            ```
        2.  sys模块：sys模块是一个与python解释器交互的借口
            ```py
            sys.argv：命令行参数类似shell的参数
            sys.exit(n)：退出程序返回一个字节码
            sys.version：python解释器信息
            sys.path：模块搜索路径
            sys.platfrom：平台信息
            ```
        3.  random模块：随机数模块
            ```py
            random.randint(m, n)：m、n之间的随机数
            random.randrange(m, n, s)：m、n之间的随机数，步长s
            random.choice(argv)：从argv中随机选择其中的数据
            ```
        4.  TIME模块：时间模块
            ```py
            time.time()：用于计算机的floats时间，时间戳
            time.strftime()：格式化时间
            ```
        5.  requests模块：requests模块在python内置模块的基础上进行了高度的封装，从而使得python进行网络请求时，变得更加简洁和人性化
            ```py
            req = requests.get(url)：get请求
            req.url
            req.headers
            req.text
            req.status_code
            req.encoding
            ```
        6.  logging模块：日志模块
            1.  日志分为五个等级
                1.  debug：详细的信息,通常只出现在诊断问题上
                2.  info：确定一切按照预期
                3.  warning：一个迹象表明,一些意想不到的事情发生了,或表明一些问题在不久的将来(例如。磁盘空间低”)。这个软件还能按预期工作。
                4.  error：严重的问题，程序不能执行一些功能
                5.  critical：一个严重的错误，程序不能执行
            ```py
            # 输出日志
            logger = logging.getLogger()
            logger.setLevel(logging.INFO) #设置输出等级
            ph = logging.StreamHandler()  #创建输出控制台的容器
            formatter = logging.Formatter("%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s") #配置输出的内容
            ph.setFormatter(formatter)   #将配置内容添加到创建的容器里
            logger.addHandler(ph)   #将我们的容器添加到handler
            logger.info("控制台输出内容")
            ####################################################################
            #写入日志
            logger = logging.getLogger() # 初始化logger
            logger.setLevel(logging.INFO) #设置log级别
            fileTimeName = time.strftime("%Y-%m-%d",time.localtime()) # 输出日期，设置log文件名字
            genpath = os.path.abspath("..") #获取到根目录
            logpath = os.path.join(genpath,"log") #拼接log文件路径
            logFileName = logpath+"/"+fileTimeName+".log"
            fh = logging.FileHandler(logFileName,mode="w",encoding="utf-8") #既然是写入文件，就需要传个文件路径和名字，mode是写入方式，encoding编码格式
            if os.path.exists(logpath): #判断路径是否存在，不存在则创建
                pass
            else:
                os.makedirs(logpath)
            formatter = logging.Formatter("%(asctime)s - %(filename)s[line:%(lineno)d] %(name)s - %(levelname)s: %(message)s")
            fh.setFormatter(formatter)
            logger.addHandler(fh)
            ```
            2.  日志格式
                ```py
                %(说明)s    ======  %(levelno)s
                levelno：打印日志级别
                levelname：打印日志级别名称
                pathname：打印当前程序执行路径
                filename：执行程序名
                lineno：打印日志当前行号
                asctime：打印日志时间
                message：打印日志信息
                ```
6. 异常处理
    ```py
    try...
    except: division by zero
    else:
    finally...
    END
    ```
    1.  错误类型都继承自BaseException，会将所有的错误包含
    2.  可通过raise主动抛出
    3.  如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出
7. Socket编程
    1.  相关模块 socket 模块
        ```py
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)#创建一个socket
        s.connect('www.baidu.com')#建立件连接
        s.send(b'GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n')
        buffer = []
        while True:
            # 每次最多接收1k字节:
            d = s.recv(1024)
            if d:
                buffer.append(d)
            else:
                break
        data = b''.join(buffer)
        s.close()
        header, html = data.split(b'\r\n\r\n', 1)
        print(header.decode('utf-8'))
        # 把接收的数据写入文件:
        with open('sina.html', 'wb') as f:  
            f.write(html)
        ```
    2.  用TCP协议进行Socket编程在Python中十分简单，对于客户端，要主动连接服务器的IP和指定端口，对于服务器，要首先监听指定端口，然后，对每一个新的连接，创建一个线程或进程来处理。通常，服务器程序会无限运行下去。同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。
    3.  DUP时无需监听端口直接发送数据接收数据
8. 并发编程
    1.  多进程
        1.  os模块或者multiprocessing模块：os.fork()、p=Process(target=func, args=(arg1, arg2)) p.start() p.join()
        2.  p = Pool(4)、p.apply_async(func, args=())、p.close()、p.join()
    2.  子进程
        1.  subprocess
            1.  s = subprocess.call(...)
            2.  s = subprocess.Popen(...), s.communicate(...)
            3.  进程间通信通过queue，pipes
    3.  多进程
        1.  threding模块
            1.  threding.Thread()
            2.  多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享
            3.  假的多线程：Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核
            4.  threadlocal

# Day 7 算法实战

## 算法实战(看懂算法原理)
## 二分查找
## 冒泡排序
## 插入排序
## 快速排序
## 选择排序

## 树
1.  树：每个节点之下有0到多个孩子节点，除了根节点，每个孩子节点都有父节点。
2.  层数：从根节点开始算起为第一层
3.  高度：从叶子节点开始算起（0）到其他节点的距离
4.  深度：从跟节点算起（0）到叶子节点的最大值

### 二叉树
1.  二叉树、完全二叉树、满二叉树
    1.  二叉树：每个节点有0到两个孩子节点
    2.  完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大（2^(层数-1)），这种二叉树叫作完全二叉树
    3.  满二叉树：每一层的个数达到最大，特殊的完全二叉树（总个数为2^n-1）
2.  存储方式
    1.  链表存储，左右指针指向孩子节点；
    2.  数组存储，下标对应关系（从1开始出发）：i为父节点，2i为左孩子，2i+1为右孩子（完全二叉树最省空间）
3.  二叉树的遍历
    1.  前序遍历：父节点》左孩子》右孩子
        ```py
        def pre(self, root):
          if not root:
            return null
          print(root.data)
          pre(root.left)
          pre(root.right)
        ```
    2.  中序遍历：左孩子》父节点》右孩子
        ```py
        def mid(self, root):
          if not root:
            return null
          mid(root.left)
          print(root.data)
          mid(root.right)
        ```
    3.  后续遍历：左孩子》右孩子》父节点
        ```py
        def post(self, root):
          if not root:
            return null
          post(root.left)
          post(root.right)
          print(root.data)
        ```
    4.  层遍历
        ```py
        def floor(self, root):
          pass
        ```

###  二叉查找树
1.  二叉查找树：在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值
2.  特点支持动态数据集合的快速插入、删除、查找操作
3.  二叉查找树操作
    1.  插入
        ```py
        def insert(self, root, value):
          troot = root
          if not troot:
            troot = NewNode(value)
            return
          while troot:
            if troot.data > value:
              if troot.left:
                troot.left = NewNode(value) # NewNode为一个新节点对象，存储数据value
                return
              troot = troot.left
            if troot.data < value:
              if troot.right:
                troot.right = NewNode(value)
                return
              troot = troot.right
        ```
    2.  查找
        ```py
        def search(self, root, value):
          troot = root
          while troot:
            if troot.data < value:
              troot = troot.right
            elif troot.data > value:
              troot = troot.left
            else:
              return troot
          return None
        ```
    3.  **删除**
    4.  最大节点
    5.  最小节点
    6.  中序遍历等于顺序输出
4.  重复数据的二叉查找树
    1.  插入
    2.  查找
    3.  删除
5.  时间空间复杂度
    1.  最坏O(n)
    2.  最好O(log n)
6.  求给定树的深度
7.  缺点：在频繁的插入和删除的操作后，可能会导致二叉查找树的性能退化，极端情况下退化为链表

### 平衡二叉查找树（红黑树）
1.  严格的定义：二叉树中任意一个节点的左右子树的高度相差不能大于1
2.  平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些
3.  **红黑树**
    1.  红黑树中的节点，一类被标记为黑色，一类被标记为红色
    2.  特点：
        1.  根节点是黑色的；
        2.  每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
        3.  任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
        4.  每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；
4.  实现

### B-tree（B树）
1.  n阶树：非根节点最多有n个子树，包含n-1个关键字；至少有n/2个子树，包含n/2-1个关键字
2.  所有叶子几点都在一层上
3.  数据左小右大
4.  维持动态平衡

### B+树
1.  根节点至少一个元素
2.  非根节点元素范围：m/2 <= k <= m-1

### B树与B+树异同
1.  相同点
    1.  根节点至少一个元素
    2.  非根节点元素范围：m/2 <= k <= m-1
2.  不同点
    1.  B+树内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。
    2.  B+树左小右大于等于
    3.  每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接
    4.  父节点存有右孩子的第一个元素的索引
3.  **mysql选用b+树作为索引数据结构**
    1.  非叶子节点不存储数据，则能存更多的更多的元素；进一步减少磁盘io
    2.  每个查询都能查到叶子节点，性能稳定
    3.  叶子节点间有指针，顺序范围查找更快

### 递归树
