---
title: redis基础学习
date: 2020-03-22  10:14:00
categories: Redis
---
<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [redis基础](#redis基础)
- [数据类型](#数据类型)
  - [string类型](#string类型)
  - [hash类型](#hash类型)
  - [list类型](#list类型)
  - [set类型](#set类型)
  - [sort set](#sort-set)
  - [高级用法](#高级用法)
- [事务](#事务)
- [持久化](#持久化)
- [redis集群](#redis集群)
  - [主从模式](#主从模式)
  - [Sentinel模式（哨兵模式）](#sentinel模式哨兵模式)
  - [cluster模式](#cluster模式)
- [redis失效机制与淘汰策略](#redis失效机制与淘汰策略)
  - [被动删除](#被动删除)
  - [主动删除](#主动删除)
  - [淘汰策略](#淘汰策略)
  - [lru淘汰、ttl淘汰与随机淘汰](#lru淘汰ttl淘汰与随机淘汰)
- [缓存相关](#缓存相关)
  - [缓存穿透](#缓存穿透)
- [参考文案](#参考文案)
<!-- TOC END -->
<!--more-->

# redis基础
- 基础学习

![redis_base_knowledge](http://study.jeffqi.cn/mysql/redis_base_knowledge.jpg)

# 数据类型

## string类型
String 类型是 Redis 中最常使用的类型，内部的实现是通过 SDS（Simple Dynamic String ）来存储的；类似python中内存池机制，预先申请一块内存来频繁创建释对象

这是最简单的类型，就是普通的 set 和 get，做简单的 KV 缓存

**string适用范围较广**
- 缓存功能：String字符串是最常用的数据类型，不仅仅是Redis，各个语言都是最基本类型，因此，利用Redis作为缓存，配合其它数据库作为存储层，利用Redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。

- 计数器：许多系统都会使用Redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。

- 共享用户Session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存Cookie，但是可以利用Redis将用户的Session集中管理，在这种模式只需要保证Redis的高可用，每次用户Session的更新和获取都可以快速完成。大大提高效率。

## hash类型
这个是类似 Map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，然后每次读写缓存的时候，可以就操作 Hash 里的某个字段。

但是这个的场景其实还是多少单一了一些，因为现在很多对象都是比较复杂的，比如你的商品对象可能里面就包含了很多属性，其中也有对象。我自己使用的场景用得不是那么多。

## list类型
List 是有序列表，可以玩儿出很多花样。

比如可以通过 List 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。

比如可以通过 lrange 命令，读取某个闭区间内的元素，可以基于 List 实现分页查询，这个是很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。

比如可以搞个简单的消息队列，从 List 头怼进去，从 List 屁股那里弄出来。

List本身就是我们在开发过程中比较常用的数据结构了，热点数据更不用说了。

- **消息队列**：
Redis的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的“抢”列表尾部的数据。

- **文章列表或者数据分页展示**：
比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用Redis的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率

## set类型
**Set 是无序集合，会自动去重的那种。**


直接基于 Set 将系统里需要去重的数据扔进去，自动就给去重了；如果你的某个系统部署在多台机器上呢？得基于Redis进行全局的 Set 去重。

可以基于 Set 玩儿**交集、并集、差集**的操作，比如交集吧，我们可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁

对比很快，操作也简单

## sort set
Sorted set 是排序的 Set，去重但可以排序，写进去的时候给一个分数，自动根据分数排序。

有序集合的使用场景与集合类似，但是set集合不是自动有序的，而Sorted set可以利用分数进行成员间的排序，而且是插入时就排序好。所以当你需要一个有序且不重复的集合列表时，就可以选择Sorted set数据结构作为选择方案。

- 排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。

- **带权重** 的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。


| 类型 | 简介 | 特性 | 场景 |
|---|---|---|---|
| String(字符串) | 二进制安全 | 可以包含任何数据，比如jpg图片或者序列化的对象，一个键最大能存储512M | |
| Hash(字典) | 键值对集合，即编程语言中的Map类型 | 适合存储对象，并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去) | 存储、读取、修改用户属性 |
| List(列表) | 链表(双向链表) | 增删快，提供了操作某一段元素的API | 1，最新消息排行等功能(比如朋友圈的时间线) 2，消息队列 |
| Set(集合) | 哈希表实现，元素不重复 | 1，添加、删除，查找的复杂度都是O(1) 2，为集合提供了求交集、并集、差集等操作 | 1，共同好友 2，利用唯一性，统计访问网站的所有独立ip 3，好用推荐时，根据tag求交集，大于某个阈值就可以推荐 |
| Sorted Set(有序集合) | 将Set中的元素增加一个权重参数score，元素按score有序排列 | 数据插入集合时，已经进行天然排序 | 1，排行榜 2，带权重的消息队列 |

## 高级用法
- ### bitmap
位图是支持按 bit 位来存储信息，可以用来实现 布隆过滤器（BloomFilter）

- ### hyperLogLog
不精确的去重计数功能，比较适合用来做大规模数据的去重统计

- ### geospatial
可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？

这三个其实也可以算作一种数据结构，不知道还有多少朋友记得，我在梦开始的地方，Redis基础中提到过，你如果只知道五种基础类型那只能拿60分，如果你能讲出高级用法，那就觉得你有点东西。

- ### pub/sub
功能是订阅发布功能，可以用作简单的消息队列。

# 事务
Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。

# 持久化
Redis 提供了 RDB 和 AOF 两种持久化方式，RDB 是把**内存中的数据集以快照形式写入磁盘**，实际操作是通过 fork 子进程执行，采用二进制压缩存储；AOF 是**以文本日志的形式记录 Redis 处理的每一个写入或删除操作**。

- ## rdb
    - **工作原理及过程**：RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，**先将数据集写入临时文件，写入成功后，再替换之前的文件**，用二进制压缩存储。RDB是Redis默认的持久化方式，会在对应的目录下生产一个dump.rdb文件，重启会通过加载dump.rdb文件恢复数据。

    - 优点：
        1.  只有一个文件dump.rdb，方便持久化；
        2.  容灾性好，一个文件可以保存到安全的磁盘；
        3.  性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化（使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能) ；
        4.  如果数据集偏大，RDB的启动效率会比AOF更高。

    - 缺点：
        1.  数据安全性低。（RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不是特别严格的时候）
        2.  由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。

- ## aof
    - **工作原理及过程**：AOF持久化是以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，文件中可以看到详细的操作记录。她的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。**Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。**

    - 优点：
        1.  数据安全性更高，AOF持久化可以配置appendfsync属性，其中always，每一次操作做都记录到日志中

        2.  通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题。

        3.  AOF机制的rewrite模式。(AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）)

    - 缺点：
        1.  AOF文件较大，数据集大是效率低；启动时顺序执行日志，速度没有RDB快

        2.  同步策略不同，运行的效率也会慢于RDB

- ## redis启动加载过程
    1. 初始化全局服务器配置

    2. 加载配置文件（如果指定了配置文件，否则使用默认配置）

    3. 初始化服务器

    4. 加载数据库

    5. 网络监听

- ### 初始化服务器配置
    初始化全局服务器配置通过initServerConfig()函数完成，主要是初始化server变量

    1. 网络监听相关，如绑定地址，TCP端口等
    2. 虚拟内存相关，如swap文件、page大小等
    3. 保存机制，多长时间内有多少次更新才进行保存
    4. 复制相关，如是否是slave，master地址、端口
    5. Hash相关设置
    6. 初始化命令表

- ### 加载配置文件
    如果指定了配置文件，Redis使用loadServerConfig()函数加载配置文件，使用标准I/O库打开配置文件，循环读取每一行然后覆盖上一步进行的默认配置。

    **如果不指定配置文件。redis不会使用默认配置文件的配置，而是使用上面初始化的参数皮遏制**

- ### 初始化服务器
    初始化服务器的工作在initServer()函数中，主要是完成前面未完成的工作，继续对server变量初始化

- ### 加载数据库
    在完成了上面的所有的初始化工作之后，Redis开始加载数据到内存中，**如果启用了appendonly了，则Redis从appendfile加载数据，否则就从dbfile加载数据**。

    1.  appendonly：在加载数据的时候只要重新执行一遍aof中的命令即可
    2.  dbfile：从数据库文件中加载数据到内存
        1. 处理SELECT命令，即选择数据库
        1. 读取key
        1. 读取value
        1. 检测key是否过期
        1. 添加新的对象到哈希表
        1. 设置过期时间（如果需要）
        1. 如果开启了VM，处理swap操作

    加载流程图

    ![redis_reload_data](http://study.jeffqi.cn/linux/redis_reload_data.png)

- ### 网络监听
    在完成了初始化配置和数据加载后，Redis启动监听。

# redis集群
- ## 三种模式
    1.  主从模式
    2.  Sentinel模式
    3.  cluster模式

## 主从模式
- ### 工作机制
    当slave启动后，主动向master发送sync命令。master接受到SYNC命令后在后台保存快照并缓存在保存快照这段时间执行的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接受到快照文件和命令后加载快照文件和缓存的执行命令。

- ### 特点
    - 主数据库可以进行读写操作，当读写操作导致数据变化是自动同步到从数据库
    - 从数据库只读，接受同步的数据
    - 一个master可以拥有多个slave，一个slave只属于一个master
    - slave挂了不影响其他slave的读和master的读写，重启后自动同步数据
    - **master挂了，不影响slave的读，但redis不可以再写，不会重新进行master的选举**
- ### 缺点
    - 若master挂了，则redis无法对外提供写服务

## Sentinel模式（哨兵模式）
- ### 工作机制
    1.  每个sentinel每秒钟发送一次ping命令个master、slave、sentinel，如果距离最后一次实例回复ping命令的时间操作预先设置的down-after-milliseconds就标记实例为主观下线
    2.  如果一个master被标记为主管下线，则正在监视这个master的所有sentinel要以每秒一次的频率确认master的确进入了主观下线
    3.  如果有足够多的数量（设置的数值）的sentinel确认master进入主观下线，则这台master进入客观下线
    4.  sentinel默认每 10 秒一次的频率向它已知的所有master，slave发送 INFO 命令。当master被sentinel标记为客观下线时，sentinel向下线的master的所有slave发送 INFO 命令的频率会从 10 秒一次改为 1 秒一次
    5.  如果没有足够多的sentinel同意master下线，；如果master重新上线向sentinel回复ping命令，master的主观下线状态就会被移除

- ### 特点
    - sentinel模式简历在主从模式之上
    - sentinel通过选举出一个新的redis实例作为master，通知其他节点修改配置，指向新的master
    - 原master重新上线只能作为slave
    - 需要保证master高可用

- ### 缺点
    - 当数据量过大，一台master无法存放，主从模式和sentinel模式都不能满足要求

## cluster模式
cluster模式的出现就是为了解决单机Redis容量有限的问题，将Redis的数据根据一定的规则分配到多台机器。

cluster可以说是sentinel和主从模式的结合体，通过cluster可以实现主从和master重选功能，所以如果配置两个副本三个分片的话，就需要六个Redis实例。

Redis的数据是根据一定规则分配到cluster的不同机器的，当数据量过大时，可以新增机器进行扩容。

使用集群，只需要将redis配置文件中的cluster-enable配置打开即可。每个集群中至少需要三个主数据库才能正常运行，新增节点非常方便。

- ### 特点
    - 多个redis实例之间网络互通，数据共享
    - 所有节点都是一主一到多从，
    - 支持在线扩展节点，删除节点
    - 任意master节点可读写

# redis失效机制与淘汰策略

## 被动删除
- 读写一个已过期的key，会触发删除操作，直接删除这个过期的key
- ### 优点：被动删除对cpu比较友好，不需要消耗cpu资源来主动检查
- ### 缺点：内存中可能存在较多的过期的key，导致资源浪费

## 主动删除
被动删除会导致一些冷数据的长时间停留，所以需要使用主动删除来解决这些冷数据的key

- ### 工作流程：
    redis周期性执行这个清除计划，默认100ms。每次循环随机抽取20个key进行检查，如果少于25%的可以是过期的key，则清除这些冷数据key，然后停止执行任务。否则会当前一轮的检查结束后，会开启下一轮的检查。这个任务的执行时间超过了一定时间，就会被终止，防止消耗过多cpu

- ### 优点：对于冷数据的key能够及时的清理，防止占用过多内存
- ### 缺点：与被动删除相反，主动删除对cpu不友好，需要进行主动检

## 淘汰策略
如果失效的key没有被访问，也未被主动删除随机选中，可能就会永久存在

所以redis中有一个maxmemory配置，即redis最大能使用的内存，当redis的使用内存达到这个值，会根据配置的淘汰策略，对redis的key进行淘汰。

- ### 六种淘汰策略
1.  **vlatile-lru**:从设置过期时间的数据集（server.db[i].expires）中挑选出最近最少使用的数据淘汰。没有设置过期时间的key不会被淘汰，这样就可以在增加内存空间的同时保证需要持久化的数据不会丢失。

2.  **vlatile-ttl**:除了淘汰机制采用LRU，策略基本上与volatile-lru相似，从设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰，ttl值越大越优先被淘汰。

3.  **vlatile-random**:从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。当内存达到限制无法写入非过期时间的数据集时，可以通过该淘汰策略在主键空间中随机移除某个key。

4.  **allkeys-lru**:从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰，该策略要淘汰的key面向的是全体key集合，而非过期的key集合。

5.  **allkeys-random**:从数据集(server.db[i].dict）中选择任意数据淘汰。

6.  **no-enviction**:禁止驱逐数据，也就是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失，这也是系统默认的一种淘汰策略。

## lru淘汰、ttl淘汰与随机淘汰
- ### lru淘汰
    LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。

    在服务器配置中保存了 lru 计数器 server.lrulock，会定时（redis 定时程序 serverCorn()）更新，server.lrulock 的值是根据 server.unixtime 计算出来进行排序的，然后选择最近使用时间最久的数据进行删除

    在服务器配置中保存了 lru 计数器 server.lrulock，会定时（redis 定时程序 serverCorn()）更新，server.lrulock 的值是根据 server.unixtime 计算出来进行排序的，然后选择最近使用时间最久的数据进行删除

- ### ttl淘汰
    Redis 数据集数据结构中保存了键值对过期时间的表，即 redisDb.expires。与 LRU 数据淘汰机制类似，TTL 数据淘汰机制中会先从过期时间的表中随机挑选几个键值对，取出其中 ttl 最大的键值对淘汰。同样，TTL淘汰策略并不是面向所有过期时间的表中最快过期的键值对，而只是随机挑选的几个键值对。

- ### 随机淘汰
    在随机淘汰的场景下获取待删除的键值对，随机找hash桶再次hash指定位置的dictEntry即可。

# 缓存相关

## 缓存穿透
- **缓存穿透**：如果我们查询一个不存在的数据，则会造成一直读取数据库，如果有人恶意攻击，则会造成数据库压力过大，甚至压垮服务器，这就是所谓的缓存穿透。
- 解决方案：
    1.  利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试
    2.  如果查询出的数据为空，也放入redis缓存，只是缓存时间设置短一些

- **缓存雪崩**：redis缓存放入大量key，然后某个时间点缓存集中过期失效。此刻就会造成大量的请求过来都会去同时查询数据库，而不走redis缓存，数据库压力陡增，在秒杀，双11等场景下，很容易压垮服务器。
- 解决方案：
    1.  缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
    2.  如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。
    3.  设置热点数据永远不过期.

- **缓存击穿**：在某些特殊节点,一个热点数据被频繁访问,在失效的瞬间就会有大量的请求进来,导致部分越过缓存去读取数据库。
- 解决方案：
    1.  双重校验（Dubbo Check）类似线程安全的懒汉单例模式实现，保证只会有一个线程去访问数据库。

# 参考文案
- [redis淘汰机制](https://www.jianshu.com/p/b1b4eeccc140)
- [redis配置](https://www.cnblogs.com/vieta/p/11192137.html)
- [redis哨兵机制](https://www.cnblogs.com/happydreamzjl/p/11322937.html)
- [redis缓存](https://www.cnblogs.com/llaq/p/9470055.html)
- [redis重写原理](https://blog.csdn.net/hezhiqiang1314/article/details/69396887)
- [redis启动流程](https://www.cnblogs.com/cuijl/p/7992433.html)
