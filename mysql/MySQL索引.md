---
title: MySQL索引
date: 2019-12-10 14:51:00
categories: MySQL
---

## 索引
- 索引是特殊的数据结构
- 索引可以加速数据库对数据的检索速度，对数据进行排序
- 索引就是对数据进行排序加速检索速度的特殊数据结构

## 索引的优缺点
- 优点
  1. 建立索引可以加速对于数据的检索速度
  2. 可以消除排序的操作，加快 SQL 执行速度，节省 CPU 资源
  3. 可以较低磁盘的 IO 读写
- 缺点
  1. 索引实质还是一张表，建立索引意味着额外的资源开销
  2. 维护许多索引需要较大的内存等资源开销
  3. 索引加快了读操作，但是降低了写操作的速度，因为修改表的操作同时需要对索引进行修改
  4. 需要花费更多的时间来建立一个优秀的索引

### 常见索引类型
#### 哈希索引：kv键值对类型，通过计算将查找值换算成一个具体位置，然后取出数据
1. 无序索引,数据添加容易,直接追加
2. 适合等值查找，范围查找性能差
#### 有序数组：按照字段排序来确定存放位置
- 采用N叉树：B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数
1. 有序索引，范围查找更优秀
2. 适用于静态存储引擎
3. 插入数据删除数据时存在一定问题，可能会导致页分裂和页合并，造成数据的空洞

### Innodb的索引模型
- InnoDB 中，表都是根据主键顺序以索引的形式存放
- 主键为聚簇索引：主键索引的叶子节点存的是整行数据
- 非主键索引：非主键索引的叶子节点内容是主键的值（二级索引）
- 回表：在非主键索引中找到主键，然后回到主键索引树搜索的操作

#### 覆盖索引
- 在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引
- 覆盖索引可以减少树的搜索次数，显著提升查询性能

#### 最左匹配原则
- 利用索引的“最左前缀”，来定位记录
- 如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的

#### 索引下推
- 在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数

### 小结
- 普通索引重建时可以提高磁盘利用率，使索引更紧凑
- 重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建；建议使用 “alter table T engine=InnoDB”

## 索引选择出错

```sql
set long_query_time=0;    //开启慢查询
select * from t where a between 10000 and 20000;    //普通查询
select * from t force index(a) where a between 10000 and 20000;   //强制索引查询
```

- 由优化器选择出最有索引，通过扫描行数来决定最优的，越少则访问磁盘次数最少

- 区分度：索引统计信息，索引的不同值的多少。不同值越多，区分度愈大。区分度大好

  ```sql
  show index from table_nane;//查看基数值
  ```

  1.  通过局部估算来获得基数值。InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数。当数据库修改的数据超过阈值 1/M 时会重新计算基数值。也可以手动重新计算基数值。
      ```sql
      analyze table table_name;//重新计算基数值
      ```
  2.  两种统计方法置参数 innodb_stats_persistent
      1.  设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。
      2.  设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。

## 字符串索引创建
1.  直接索引，使用较大存储空间
2.  前缀索引，增加回表次数，无法使用覆盖索引
3.  倒叙再前缀索引，弥补前缀索引区分度不够
4.  hash索引，性能稳定，额外开销

## 索引失效案例

### 条件函数操作

1.   如果在 sql 语句中条件不部分使用了函数操作，则会导致索引失效，走全盘扫描。
  ```sql
  select count(*) from tradelog where month(t_modified)=7;
  ```

  - 对索引字段做函数操作，可能会破坏索引值的有序性，优化器就决定放弃走树搜索功能
  -   对于索引右边的数据可以进行函数操作

  - **解决**：避免在 where 条件中左边使用函数操作

2.  隐式类型转换
  - 字符串和数字做比较的话，是将字符串转换成数字（同使用了函数操作类似）
  - **解决**：写语句时注意字段类型

3.  隐式字符编码转换
  - 关联表中的数据进行对比时如果不是一个字符集则需要进行类型转换
  - **解决**：连接过程中要求在被驱动表的索引字段上加函数操作，是直接导致对被驱动表做全表扫描的原因
