---
title: MySQL全局锁与表锁
date: 2020-02-12 19:26:00
tags: MySQL知识
categories: MySQL
---
## MySQL锁
- 计算机协调多个进程或线程并发访问同一资源的机制
- MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类
- 锁分类
  1. 表锁：开销小，性能差
  2. 页锁：介于行锁与表锁之间
  3. 行锁：开销大，性能好，适于高并发
  4. 间隙锁：解决幻读的锁
- 读锁：阻塞写不阻塞读，只能操作自己上锁表和数据
- 写锁：同时阻塞读写，其他会话的写操作会阻塞

### 全局锁
- 命令
  ```sql
  flush tables with read lock;  /*此时整个库处于只读状态*/
  ```
- 不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的
- MySQL中的innodb支持事务：当 mysqldump 使用参数：–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图；同时过程中数据可更新
- 推荐使用ftwrl命令，少用set global variable readonly=true
  1. readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库
  2. 执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁；而后者则会一直持有锁不会自动释放

1. 查看加锁表
    ```sql
    show open tables;
    ```
2.  查看分析表锁
    ```sql
    show status like 'Table_lock%';
    table_lock_immediate  /*累计加锁次数*/
    table_lock_waited /*正在等待的加索的进程*/
    ```

### 表级锁

#### 表锁
- 语法
  ```sql
  lock tables … read/write #加锁
  unlock tables #释放
  ```

#### 元数据锁
- 访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性
- 当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁
  - 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查
  - 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性
  - **事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放**，需要小心使用避免误操作使数据库挂掉。在拿不到MDL使需要进行处理
    - 这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃
    - DDL NOWAIT/WAIT n 语法
      ```sql
      ALTER TABLE tbl_name NOWAIT add column ...
      ALTER TABLE tbl_name WAIT N add column ...
      ```

### 行锁

#### 行锁
- 行锁实现于存储引擎层
1. 事务的ACID特性（原子性，一致性，隔离性，持久性）
2. 事务隔离级别（read uncommited,read commited,repeatable read,lock read）

  隔离级别|脏读|不可重复读|幻读
  ---|---|---|---
  read uncommited | Y | Y | Y
  read commited | Y | Y| Y
  repeatable read | Y | Y | Y
  lock read | Y | Y | Y

3. 查看当前事务隔离级别
    ```sql
    show variables lik 'transaction_isolation';
    ```

4. 索引失效会导致行锁变为表锁；例如使用类型转换
5. 间隙锁会在锁定一个范围导致一些操作无法操作
6. 锁定一行
    ```sql
    select * from s for update;
    ```

#### 间隙锁（gap锁）
- 为了解决幻读问题，InnoDB 引入新的锁，也就是间隙锁 (Gap Lock)
- 间隙锁，锁的就是两个值之间的空隙
- 跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系
- 间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间
- 间隙锁的引入，解决了幻读的问题。但是导致同样的语句锁住更大的范围，影响了并发度
- 你如果把隔离级别设置为读提交，就没有间隙锁了。但同时需要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row

#### 两阶段锁
- innodb中行锁在需要时加上，事务提交时释放
- **如果需要锁多行，则需要将并发度高的放后面**

#### 死锁于死锁检测
- 死锁：由于不同线程出现资源相互等待而进入无限循环状态
  - 解决方法：
    1. 等待超时：参数：innodb_lock_wait_timeout：设置等待超时时间
    2. 死锁检测：参数：innodb_deadlock_detect：设置开启死锁检测
  - 解决方案的优缺点
- 提高并发度建议：
  1. 关闭死锁检测
  2. 控制并发数
  3. 逻辑上通过将一行使用多行来代替

### 加锁规则（两原则，两优化，一bug）
1.  原则 1：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间
2.  原则 2：查找过程中访问到的对象才会加锁
3.  优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁
4.  优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁
5.  一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止

#### 上锁注意点
- 锁是加载在索引上。执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁
- 删除数据的时候尽量加 limit。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围
- next-key lock 先是加间隙锁，加锁成功；然后加上行锁
- 读提交隔离级别下：语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交

### 小结
- MySQL全局锁与表级锁
- 备库时看是否支持事务，选择锁库方式
- 注意MDL元数据表锁的使用
- 数据库出现 lock tables 语句时，需要引起注意。检查存储引擎和业务代码
