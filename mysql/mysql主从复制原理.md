---
title: mysql主从复制
date: 2020-03-23 10:26:00
categories: MySQL
---
<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
- [啥是主从复制？](#啥是主从复制)
- [主从复制有什么用？](#主从复制有什么用)
- [主从模式](#主从模式)
  - [一主一从、一主多从](#一主一从一主多从)
  - [多主一从](#多主一从)
  - [双主模式](#双主模式)
  - [级联复制](#级联复制)
- [mysql主从复制原理](#mysql主从复制原理)
  - [复制流程](#复制流程)
- [mysql复制模式](#mysql复制模式)
- [性能提升](#性能提升)
  - [支持发送二进制日志事件和接收ACK的异步化](#支持发送二进制日志事件和接收ack的异步化)
  - [控制主库接收确认反馈从库的数量](#控制主库接收确认反馈从库的数量)
- [日志格式](#日志格式)
  - [binlog记录格式](#binlog记录格式)
- [基于GTID复制实现的工作原理](#基于gtid复制实现的工作原理)
- [参考文档](#参考文档)
<!-- TOC END -->
<!--more-->

# 啥是主从复制？
- 主从复制就就是将主服务器上的数据，复制到一个或多个从服务器上；mysql默认采用异步复制，从节点可以复制主节点上的指定的数据库；

# 主从复制有什么用？
- **提供读写分离的能力**：从服务器可以分代主库的读请求的压力，让主库更专注于数据的更新和写操作，有更好的写性能；

- **数据备份**：从库上拥有主库的完整的二进制日志，应用后可拥有和主库几乎相等的数据；在主库某些不可抗力的影响后，依旧能够保证真个数据库数据的完整性；方便切换

- **高可用**：主从复制是高可用的基础；可以使用多个节点来避免单点故障

- **架构扩展**：可以随着业务的增加，可以通过增加节点来提高适应能力。分担压力，将压力负载到多态服务器上

# 主从模式

## 一主一从、一主多从
- 一主一到多从模式可以提升整个数据库的读能力，分代主库的压力

![1-m-1-s](http://study.jeffqi.cn/mysql/1_m_1_s.jpg)
![1-m-mulits-s](http://study.jeffqi.cn/mysql/1_m_mulits_s.jpg)

## 多主一从
- 将多个主库的数据存储到一台存储性能好的服务器中

![mulits-m-1-s](http://study.jeffqi.cn/mysql/mulits_m_1_s.jpg)

## 双主模式
- 两台服务器互为主从，任意一个master修改后都会将数据日志复制到对方去；避免循环复制，从服务器在应用日志后，写日志时将日志的server-id改为应用日志的server-id，这样发送回去的时候主服务器就能够识别

![double-m](http://study.jeffqi.cn/mysql/double_m.jpg)

## 级联复制
- 部分slave的数据同步不连接主节点，而是连接从节点。因为如果主节点有太多的从节点，就会损耗一部分性能用于replication，那么我们可以让3~5个从节点连接主节点，其它从节点作为二级或者三级与从节点连接，这样不仅可以缓解主节点的压力，并且对数据一致性没有负面影响

![m-s-s](http://study.jeffqi.cn/mysql/m-s-s.jpg)

# mysql主从复制原理
- mysql主从复制中有三个线程**dump thread（master）、io thread（slave）、sql thread（slave）**

- **dump thread**：当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，在发动给从节点之后，锁会被释放。

- **io thread**：从节点上用来想主服务器请求日志，接收从主服务器发送的binlog，并更新到本地的relay-log中。

- **sql thread**：SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。

- 当主节点有多个从节点时，主节点会为每一个当前连接的从节点建一个binary log dump 进程，而每个从节点都有自己的I/O进程，SQL进程。从节点用两个线程将从主库拉取更新和执行分成独立的任务，这样在执行同步数据任务的时候，不会降低读操作的性能。

## 复制流程
- 从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；

- 主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position；从节点的I/O进程接收到内容后，将接收到的日志内容更新到本机的relay log中，并将读取到的binary log文件名和位置保存到master-info 文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；

- Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。

![mysql-replication_processes](http://study.jeffqi.cn/mysql/mysql_replication_processes.png)

# mysql复制模式
- 异步复制
![mysql_async_repl](http://study.jeffqi.cn/mysql/mysql_async_repl.jpg)
- 同步复制
![mysql_(semi)\_repl](http://study.jeffqi.cn/mysql/mysql_%28semi%29_sync.jpg)
- 半同步复制

- ## 异步复制
    主节点不会主动推送二进制日志到从服务器，需要从服务器发起请求；主服务器的事务完成提交后立即返回结果给客户端，需要等待从服务器的确认。

    - **优点**：数据库吞吐量大，性能好

    - **缺点**：因为不需要其他数据库的确认，可能在master宕机后，造成数据的丢失；从服务器也不能及时的更新数据

- ## 同步复制
    当主库提交事务时，**所有从库**也将在主库返回执行事务的会话之前**提交事务**。这样能够保证数据的一致性和完整性

    - **有点**：数据库数据有备份，完整性好

    - **缺点**：需要等待从库确认，主动推送日志，会有性能消耗；事务的过程边长

- ## 半同步复制
    介于异步和完全同步复制之间。主库仅等待**至少一个从库接收并记录事件**。它不会等待所有从库确认收到，并且**从库只需要确认接收**，而不是事件已在从库完全执行和提交。

    - **优点**：至少有一个从库确认了二进制日志，保证了数据的完整性；同时不需要等待所有从库的确认，响应速度更快

    - **缺点**：因为需要等待至少一个从库，所以有性能消耗；同时如果读写分离的读操作落在不是确认了日志的服务器上，会出现延迟更新的问题

# 性能提升

## 支持发送二进制日志事件和接收ACK的异步化
-  旧版本的半同步复制受限于Binlog Dump线程，原因是该线程承担了两份不同且又十分频繁的任务：传送二进制日志事件给从库 ；接收从库的ACK反馈信息。这两个任务是串行的，Binlog Dump线程必须等待从库返回之后才会传送下一个事件。Binlog Dump线程已然成为整个半同步复制性能的瓶颈。

![old_repl_ack](http://study.jeffqi.cn/mysql/old_repl_ack.png)

- 在5.7.4版本的半同步复制框架中，独立出一个Ack Receiver线程 ，专门用于接收从库返回的ACK请求，这将之前Binlog Dump线程的发送和接收工作分为了两个线程来处理。这样主库上有两个线程独立工作，可以同时发送二进制日志事件到从库，和接收从库的ACK信息

![new_repl_ack](http://study.jeffqi.cn/mysql/new_repl_ack.png)

-  Ack Receiver线程在主库启用半同步复制时创建，并在主库禁用半同步复制时销毁。它是自动创建和销毁的，因此不受用户控制

- 在MySQL 5.7.17之前，这个Ack Receiver线程采用了**select机制来监听**从库返回的结果，然而select机制监控的文件句柄只能是0-1024，当超过1024时，用户在MySQL的错误日志中或许会收到类似如下的报错，更有甚者会导致MySQL发生宕机。

- MySQL 5.7.17版本开始，官方修复了这个bug，开始使用**poll机制来替换原来的select机制**，从而可以避免上面的问题。其实poll调用本质上和select没有区别，只是在I/O句柄数理论上没有上限

## 控制主库接收确认反馈从库的数量
- MySQL 5.7新增了rpl_semi_sync_master_wait_for_slave_count系统变量，可以用来控制主库接收多少个从库写事务成功反馈，给高可用架构切换提供了灵活性。当该变量值为2时，主库需等待两个从库的ACK。

- 当然啦，数字越大越安全咯；因为更接近全同步复制了（手动滑稽）

# 日志格式
- statment
- row
- mix

## binlog记录格式
- ### statment格式
    该模式记录每一条sql语句，对于所有的增删改语句进行记录。日志文件较小，节约了io。但是在一些极端情况下会照成数据的不一致；

- ### row格式
     Row-based Relication(RBR)是mysql master将SQL语句分解为基于Row更改的语句并记录在bin log中，也就是只记录哪条数据被修改了，修改成什么样；恢复数据是比较方便，不会出现不一致的问题；缺点是日志文件过大也不能通过bin log解析获取执行过的sql语句，只能看到发生的data变更；也不能通过bin log解析获取执行过的sql语句，只能看到发生的data变更

- ### mix格式
    是以上两种模式的混合，对于一般的复制使用STATEMENT模式保存到binlog，对于STATEMENT模式无法复制的操作则使用ROW模式来保存，MySQL会根据执行的SQL语句选择日志保存方式

# 基于GTID复制实现的工作原理
- 在传统的复制里面，当发生故障，需要主从切换，需要找到binlog和pos点，然后将主节点指向新的主节点，相对来说比较麻烦，也容易出错；使用GTID进行复制不需要其他的操作；MySQL会通过内部机制GTID自动找点同步。

- **工作流程**
    1.  主节点更新数据时，会在事务前产生GTID，一起记录到binlog日志中。
    2.  从节点的I/O线程将变更的bin log，写入到本地的relay log中。
    3.  SQL线程从relay log中获取GTID，然后对比本地binlog是否有记录（所以MySQL从节点必须要开启binary log）。
    4.  如果有记录，说明该GTID的事务已经执行，从节点会忽略。
    5.  如果没有记录，从节点就会从relay log中执行该GTID的事务，并记录到bin log。
    6.  在解析过程中会判断是否有主键，如果没有就用二级索引，如果有就用全部扫描。（**没明白**）

# 参考文档
- [深度探索MySQL主从复制原理](https://zhuanlan.zhihu.com/p/50597960)
- [mysql8复制-半同步复制](https://cloud.tencent.com/developer/article/1433074)
- [mysql8复制-半同步复制配置](https://wxy0327.blog.csdn.net/article/details/90081518)
- [MySQL是怎么保证主备一致的？(极客时间)](https://time.geekbang.org/column/article/76446)
